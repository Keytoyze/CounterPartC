# This file can help to generate cpp header codes of AST!
import os

signs = [
    (">>=", "RIGHT_ASSIGN"),
    ("<<=", "LEFT_ASSIGN"),
    ("+=", "ADD_ASSIGN"),
    ("-=", "SUB_ASSIGN"),
    ("*=", "MUL_ASSIGN"),
    ("/=", "DIV_ASSIGN"),
    ("%=", "MOD_ASSIGN"),
    ("&=", "AND_ASSIGN"),
    ("^=", "XOR_ASSIGN"),
    ("|=", "OR_ASSIGN"),
    (">>", "RIGHT_OP"),
    ("<<", "LEFT_OP"),
    ("++", "INC_OP"),
    ("--", "DEC_OP"),
    ("->", "PTR_OP"),
    ("&&", "AND_OP"),
    ("||", "OR_OP"),
    ("<=", "LE_OP"),
    (">=", "GE_OP"),
    ("==", "EQ_OP"),
    ("!=", "NE_OP"),
    (";", "SIMICOLON_SINGLE"),
    (",", "COMMA"),
    (":", "COLON"),
    ("=", "EQ"),
    ("[", "L_SQUARE"),
    ("]", "R_SQUARE"),
    (".", "PERIOD"),
    ("&", "AND"),
    ("!", "EXCLAMATION"),
    ("~", "TILDE"),
    ("-", "SUB"),
    ("+", "ADD"),
    ("*", "MUL"),
    ("/", "DIV"),
    ("%", "MOD"),
    ("<", "L_ANGLE"),
    (">", "R_ANGLE"),
    ("^", "CARET"),
    ("|", "VERTICAL"),
    ("?", "QUESTION"),
    ("{", "L_CURLY"),
    ("}", "R_CURLY"),
    ("(", "L_ROUND"),
    (")", "R_ROUND")
]

signs = dict(signs)
token_to_sign = dict((y, x) for x, y in signs.items())

types = [
    ("primary_expression", "expression"),
    ("postfix_expression", "expression"),
    ("argument_expression_list", "expression"),
    ("unary_expression", "expression"),
    ("unary_operator", "expression"),
    ("cast_expression", "expression"),
    ("multiplicative_expression", "expression"),
    ("additive_expression", "expression"),
    ("shift_expression", "expression"),
    ("relational_expression", "expression"),
    ("equality_expression", "expression"),
    ("and_expression", "expression"),
    ("exclusive_or_expression", "expression"),
    ("inclusive_or_expression", "expression"),
    ("logical_and_expression", "expression"),
    ("logical_or_expression", "expression"),
    ("conditional_expression", "expression"),
    ("assignment_expression", "expression"),
    ("assignment_operator", "expression"),
    ("expression", "expression"),
    ("constant_expression", "expression"),
    ("declaration", "decl"),
    ("declaration_specifiers", "decl"),
    ("init_declarator_list", "decl"),
    ("init_declarator", "decl"),
    ("storage_class_specifier", "decl"),
    ("type_specifier", "decl"),
    ("struct_or_union_specifier", "decl"),
    ("struct_or_union", "decl"),
    ("struct_declaration_list", "decl"),
    ("struct_declaration", "decl"),
    ("specifier_qualifier_list", "decl"),
    ("struct_declarator_list", "decl"),
    ("struct_declarator", "decl"),
    ("enum_specifier", "decl"),
    ("enumerator_list", "decl"),
    ("enumerator", "decl"),
    ("type_qualifier", "decl"),
    ("declarator", "decl"),
    ("direct_declarator", "decl"),
    ("pointer", "decl"),
    ("type_qualifier_list", "decl"),
    ("parameter_type_list", "decl"),
    ("parameter_list", "decl"),
    ("parameter_declaration", "decl"),
    ("identifier_list", "decl"),
    ("type_name", "decl"),
    ("abstract_declarator", "decl"),
    ("direct_abstract_declarator", "decl"),
    ("initializer", "decl"),
    ("initializer_list", "decl"),
    ("statement", "statement"),
    ("labeled_statement", "statement"),
    ("compound_statement", "statement"),
    ("declaration_list", "statement"),
    ("statement_list", "statement"),
    ("expression_statement", "statement"),
    ("selection_statement", "statement"),
    ("iteration_statement", "statement"),
    ("jump_statement", "statement"),
    ("translation_unit", "statement"),
    ("external_declaration", "statement"),
    ("function_definition", "statement"),
]

types = dict(types)

tokens = set()
raw_bnf_text = set()

# read bnf
bnf = open("bnf.txt").read().split("\t;")
struct = {}
for sentence in bnf:
    key, value = sentence.split("\t:")
    key = key.strip()
    value = [[child.strip() for child in right.strip().split(" ")] for right in value.split("\t|")]
    struct[key] = value

template_header = """// Generated by buildSrc/GenerateAST.py
#ifndef #mark
#define #mark

//#include "ast/ast.h"
#header

class #class: public BasicAST {
public:
    virtual ~#class() {}
    virtual IRValuePtr GenerateIR(Context& context) { return nullptr; }
    virtual void Dump(int depth) {}
};

#subclasses
#endif // #mark
"""

template_class = """class #class#order: public #class {
public:
#vars

    #class#order(#const_params): #namelist {}

    virtual ~#class#order();
    virtual IRValuePtr GenerateIR(Context& context);
    virtual void Dump(int depth);

};
"""

template_class_impl = """void #class#order::Dump(int depth) {
#dump
}

#class#order::~#class#order() {
#free
}
"""

base_ast_dir = "../src/ast/"

def get_token_name(bnf_name):
    if bnf_name[0] == "'":
        return signs[bnf_name[1:-1]]
    return bnf_name

def get_class(bnf_name):
    bnf_name = get_token_name(bnf_name)
    return "".join([x.capitalize() for x in bnf_name.lower().split("_")])

def get_var(bnf_name):
    class_name = get_class(bnf_name)
    return class_name[0].lower() + class_name[1:] + "Ast"

def is_special_token(token):
    return token == 'CONSTANT' or token == 'STRING_LITERAL' or token == 'IDENTIFIER'

def get_file(bnf_name):
    
    if bnf_name[0].islower(): # non terminal
        return types[bnf_name] + "/" + bnf_name + ".h"
    else: # terminal
        raw_bnf_text.add(bnf_name)
        if bnf_name[0] == "'": # signs
            bnf_name = signs[bnf_name[1:-1]]
        tokens.add(bnf_name)
        if is_special_token(bnf_name):
            return "terminal/" + bnf_name.lower() + ".h"
        return "terminal/token.h"

total_include_set = set([
    '#include "ast/basic_ast.h"',
    '#include "ast/statement/translation_unit.h"'
    ])

def_map = {}

def write_ast(ast, d):
    file_name = get_file(ast)
    print("generate " + file_name)
    mark = '_' + ast.upper() + "_H_"
    class_name = get_class(ast)

    sub_classes = []
    sub_classes_impl = []
    include_set = set(['#include "ast/basic_ast.h"'])
    class_def_set = set()

    for i, params in enumerate(struct[ast]):
        var = ["    " + get_class(x) + "* " + get_var(x) + str(k + 1) + ";" for k, x in enumerate(params)]
        const_params = [get_class(x) + "* " + get_var(x) + str(k + 1) for k, x in enumerate(params)]
        name_list = ["{param}({param})".format(param=get_var(x) + str(k + 1)) for k, x in enumerate(params)]
        frees = ["    delete %s" % get_var(x) + str(k + 1) + ";" for k, x in enumerate(params)]
        dumps = ['    std::cout << "[" << depth << "] " << "%s%d" << std::endl;' % (class_name, i + 1)]
        dumps += ["    %s->Dump(depth + 1);" % (get_var(x) + str(k + 1)) for k, x in enumerate(params)]
        for x in params:
            if x != ast:
                include = '#include "ast/%s.h"' % get_file(x)[:-2]
                class_def = "class %s;" % get_class(x)
                include_set.add(include)
                mark2 = "_CLASS_" + get_class(x).upper() + "_"
                class_def_set.add(class_def)
                total_include_set.add(include)
        sub_classes.append((
            template_class.replace("#class", class_name)
                .replace("#order", str(i + 1))
                .replace("#vars", "\n".join(var))
                .replace("#const_params", '\n        ' + ",\n        ".join(const_params) + '\n    ')
                .replace("#namelist", ", ".join(name_list))
                
        ))
        sub_classes_impl.append((
            template_class_impl.replace("#class", class_name)
                .replace('#order', str(i + 1))
                .replace("#free", '\n'.join(frees))
                .replace("#dump", '\n'.join(dumps))
        ))

    content = (template_header
    .replace("#mark", mark)
    .replace("#class", class_name)
    .replace("#subclasses", '\n'.join(sub_classes))
    .replace("#header", '\n'.join(sorted(class_def_set)))
    )
    with open(base_ast_dir + file_name, "w") as f:
        f.write(content)
    
    with open(base_ast_dir + file_name.replace(".h", ".cpp"), "w") as f:
        f.write('// Generated by buildSrc/GenerateAST.py\n')
        f.write('#include <iostream>\n')
        f.write('#include "ast/ast.h"\n\n')
        f.write("\n".join(sub_classes_impl))

# generate type
for t, d in types.items():
    if not os.path.exists(base_ast_dir + d):
        os.mkdir(base_ast_dir + d)
    write_ast(t, d)

# generate tokens

template_token_header = """// Generated by buildSrc/GenerateAST.py
#ifndef _TOKEN_H_
#define _TOKEN_H_

#include "ast/basic_ast.h"
#include <iostream>
#include <string>

class BasicToken: public BasicAST {
private:
    std::string tokenName;
public:
    BasicToken(): tokenName("") {}
    BasicToken(std::string tokenName): tokenName(tokenName) {}
    virtual ~BasicToken() {}

    virtual IRValuePtr GenerateIR(Context& context) { return nullptr; }
    virtual void Dump(int depth) {
        if (tokenName.length() != 0) {
            std::cout << "[" << depth << "] " << tokenName << std::endl;
        }
    }
};

#classes

#endif //_TOKEN_H_
"""

def get_raw_text(bnf_name):
    if bnf_name in token_to_sign:
        return token_to_sign[bnf_name]
    return bnf_name.lower()

template_subtokens = """// #raw_text
class #class: public BasicToken {
public:
    #class(): BasicToken("#class") {}
};"""
token_def = [template_subtokens.replace("#class", get_class(x)).replace("#raw_text", get_raw_text(x)) for x in tokens if not is_special_token(x)]
token_def = sorted(token_def)
token_def = "\n\n".join(token_def)
with open("../src/ast/terminal/token.h", "w") as f:
    f.write(template_token_header.replace("#classes", token_def))

total_include_set = sorted(total_include_set)
with open("../src/ast/ast.h", "w") as f:
    f.write("\n".join(total_include_set))

# generate yacc

template_yacc = """%{
#include <cstdlib>
#include <cstdio>
#include <string>
#include <memory>
#include "ast/ast.h"
using namespace std;

extern char *yytext;
extern int column;
extern FILE * yyin;
extern FILE * yyout;
BasicAST* root;
extern int yylineno;

int yylex(void);
void yyerror(const char*); 
%}

%union {
#union
}

#token

#type

%nonassoc LOWER_THAN_ELSE
%nonassoc ELSE
%%

program: 
	translation_unit {
		root = $1;
	}
    ;

#bnf

%%

void yyerror(char const *s)
{
	fflush(stdout);
	printf("\\n%*s\\n%*s\\n", column, "^", column, s);
}


int main(int argc,char* argv[]) {

	yyin = fopen(argv[1],"r");
	
	//freopen("output/output.txt","w", stdout);
	yyparse();

    root -> Dump(0);
    delete root;
	fclose(yyin);
	return 0;
}
"""

# generate bison
union = sorted(["    %s* %s;" % (get_class(x), get_var(x)) for x in struct.keys()])
union += [
    "    // special tokens",
    "    Constant* constant;",
    "    StringLiteral* stringLiteral;",
    "    Identifier* identifier;"
]

token_out = ["%%token %s" % " ".join(sorted(raw_bnf_text))]
token_out.append("%token <constant> CONSTANT")
token_out.append("%token <stringLiteral> STRING_LITERAL")
token_out.append("%token <identifier> IDENTIFIER")

type_out = ["%%type <%s> %s" % (get_var(x), x) for x in struct.keys()]
bnf_out = []
template_bnf = """ {
        $$ = new %s%d(%s);
    }
    """
for key, ors in struct.items():
    s = "%s\n    :" % key
    for i, params in enumerate(ors):
        s += " " + " ".join(params)
        bnf_param = []
        for j, param in enumerate(params):
            if param == 'CONSTANT' or param == 'STRING_LITERAL' or param == 'IDENTIFIER' or param[0].islower():
                bnf_param.append("$%d" % (j + 1))
            else:
                bnf_param.append("new %s()" % (get_class(param)))
        s += template_bnf % (get_class(key), i + 1, ", ".join(bnf_param))
        s += "|"
    bnf_out.append(s[:-1] + ";\n")

with open("../src/cpc.y", 'w') as f:
    f.write((
        template_yacc.replace("#union", "\n".join(union))
            .replace("#token", '\n'.join(token_out))
            .replace("#type", '\n'.join(type_out))
            .replace("#bnf", '\n'.join(bnf_out))
    ))

# generate default implement

template_cpp = """#include "ast/ast.h"
#include <iostream>

#classes
"""

template_cpp_class = """// #bnf
// (#bbb)
IRValuePtr #class#order::GenerateIR(Context& context) {
    // TODO: implement me!
    std::cerr << "Not implemented!" << std::endl;
    return nullptr;
}
"""

base_ir_dir = "../src/IR/"

def write_ast_impl(ast, d):
    header = get_file(ast)
    file_name = header.replace(".h", ".cpp")
    print("generate " + file_name)

    class_name = get_class(ast)

    sub_classes = [(
        template_cpp_class.replace("#class", class_name)
            .replace("#order", str(i + 1))
            .replace("#bnf", ast + " -> " + ' '.join(struct[ast][i]))
            .replace("#bbb", get_class(ast) + " -> " + ' '.join([get_class(x) for x in struct[ast][i]]))
            ) for i in range(len(struct[ast]))]

    with open(base_ir_dir + file_name, "w") as f:
        f.write(template_cpp.replace("#header", "ast/" + header).replace("#classes", "\n".join(sub_classes)))
    
for t, d in types.items():
    if not os.path.exists(base_ir_dir + d):
        os.mkdir(base_ir_dir + d)
    write_ast_impl(t, d)